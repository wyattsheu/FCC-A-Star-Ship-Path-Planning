# FCC-A-Star-Ship-Path-Planning

A ship path planning algorithm using FCC-A\* with visualization in Pygame.

# FCC-A\* 航行路徑規劃器

## 概述

此模組實作了 FCC-A* 航行路徑規劃演算法。FCC-A* 結合了 A\* 搜索與基於 GOODWIN 船舶領域模型的模糊碰撞成本 (FCC)。它為「讓路船」(必須讓道的船舶) 計劃安全路徑，同時考慮「直航船」(具有優先權的船舶) 的預測路徑（假設其以恆定速度行駛，在接近目標時減速）。

## 功能特點

- **FCC-A\***：整合 A\* 演算法與模糊碰撞成本函數。
- **模糊碰撞成本 (FCC)**：結合兩個隸屬函數——Uθ（基於角度）與 U_dist（基於距離）——來計算碰撞風險成本。
- **直航船路徑預測**：假設直航船以恆定速度行駛，在接近目標時線性減速，以確保恰好停在目標點。
- **可視化**：作為腳本執行時，模組將顯示：
  - Pygame 視窗，展示網格上的船舶路徑（包含讓路船的標示格與逐步箭頭）。
  - 內嵌 Matplotlib 圖表，顯示「FCC vs. 步數」與「航向 vs. 步數」。

## 使用範例

以下是導入並使用 `fcc_a` 類別的範例：

```python
from FCC_A import fcc_a

# 示例：
# 船 1：速度 2 m/s，起點 (50,50)，目標點 (0,0)
# 船 2：速度 5 m/s，起點 (0,0)，目標點 (50,50)
# 設定 yield_ship = 1，將船 1 設為讓路船。
grid_scale = 1  # 每個網格代表 1 米
planner = fcc_a(
    ship1_speed=2,
    ship1_pos=(50, 50),
    ship2_speed=5,
    ship2_pos=(0, 0),
    ship1_goal=(0, 0),
    ship2_goal=(50, 50),
    yield_ship=1,
    grid_scale=grid_scale,
)
direct_path, yield_path = planner.calculate_path()
# direct_path：直航船的預測路徑（以米為單位）
# yield_path：讓路船的計劃路徑（以米為單位）
# 額外分析數據（步數、位置、航向、FCC 值）可在 planner.analysis 中找到。
```

## 初始化參數

- **ship1_speed, ship2_speed**：船 1 和船 2 的速度（m/s）。
- **ship1_pos, ship2_pos**：船舶的起始位置（以米為單位）。
- **ship1_goal, ship2_goal**：船 1 和船 2 的目標位置（以米為單位）。  
  每艘船的初始航向會自動計算為從起點指向目標點的方向。
- **yield_ship**：指定哪艘船是讓路船（需讓道的船舶）。設定為 1 表示船 1 是讓路船，設定為 2 表示船 2 是讓路船。
- **grid_scale**：將真實世界距離（米）轉換為網格單位的比例（如 0.1 米每格）。此參數影響所有距離與成本計算。

## 角色分配

類別設計會指定一艘船為讓路船（需讓道），另一艘船為直航船（維持航向）。讓路船的路徑由 FCC-A\* 演算法規劃，而直航船的路徑則假設其以恆定速度行駛，並在接近目標時減速。

## 直航船路徑預測（速度-時間圖）

直航船的預測路徑如下：

- 初始時船舶保持恆定速度行駛。
- 當距離目標的剩餘距離小於預設步數所覆蓋的距離時，船舶會線性減速至 0。

> **速度-時間圖：**
>
> - **恆定階段**：船舶速度保持不變。
> - **減速階段**：速度線性降低，直至在目標點停止。

## `calculate_path()` 方法輸入與輸出

- **輸出**：返回一個元組：
  - `direct_path`：直航船的預測路徑（(x, y) 坐標列表，單位：米）。
  - `yield_path`：讓路船的規劃路徑（(x, y) 坐標列表，單位：米）。
- **分析數據**：  
  `planner.analysis` 字典包含：
  - `steps`：步數。
  - `positions`：每一步船舶的位置信息（米）。
  - `headings`：讓路船的航向角度（度），通過滑動窗口的一階與最後向量計算獲得。
  - `fcc`：每一步的 FCC 成本值。

## 步數、船速與預測位置的關係

- 步數對應於離散的網格移動。
- 讓路船的速度 (yield_speed) 和 `grid_scale` 決定了每一步跨越的網格數量。
- 直航船的預測路徑基於其速度計算，保持恆定速度，並在接近目標時應用減速模型。

## `grid_scale` 的影響

- `grid_scale` 定義了每個網格代表的真實世界距離。
- 較小的 `grid_scale` 提供更高解析度（每米更多網格），影響距離、成本計算及真實世界座標與網格座標的轉換。

## 可調參數

雖然程式碼本身未將可調參數集中管理（以保持原始結構），但以下參數可根據需求調整：

- **GOODWIN 模型參數：**
  - `SECTER_RADIUS_LEFT`
  - `SECTER_RADIUS_RIGHT`
  - `SECTER_RADIUS_BACK`
- **fcc_scale**：控制 FCC 成本的權重。
- **k_heading**：滑動窗口大小，用於計算讓路船航向角度。

## 作為腳本運行

若直接執行此模組(即運行`python FCC_A.py`)，它將執行內建測試：

- 計算兩艘船的路徑。
- 開啟 Pygame 視窗，顯示網格上的船舶路徑：
  - 讓路船的單元格高亮顯示。
  - 箭頭指示每一步的船舶航向。
  - 顯示步數。
- 右側嵌入 Matplotlib 圖表，顯示「FCC vs. 步數」與「航向 vs. 步數」。

## 其他說明

- **A\* 演算法解釋**  
  A\* 演算法使用優先佇列，狀態定義為 `(x, y, t, h)`，其中：

  - `x, y`：網格座標。
  - `t`：步數。
  - `h`：讓路船的當前航向。
    啟發式函數結合了八向距離與 FCC 成本。

## 聯絡方式

如有問題或建議，請聯繫 [wyattsheu@gmail.com]。
